Задачи на процедурное программирование
Задача 1: Ближайший меньший справа
Условие
Для каждого элемента массива найти первый элемент справа, который меньше его. Если нет такого - вернуть -1.
Сложность: O(n)
Плохое решение (два цикла):
•	Внешний цикл: n раз
•	Внутренний цикл: n/2 раз
•	Всего операций: n × (n/2) = n*n/2
•	Итого сложность: O(n*n)
Хорошее решение:
Если посчитать, сколько раз программа касается каждого элемента, можно заметить:
1.	Проходим по массиву один раз слева направо - это n операций
2.	Каждый элемент кладётся в стек один раз - ещё n операций в сумме
3.	Каждый элемент достаётся из стека максимум один раз - ещё до n операций
Итого примерно 3n операций. В Big O нотации мы отбрасываем числа и оставляем только главное - O(n).
Проверка на примере:
Для массива [4, 8, 5, 2, 25]:
•	Плохое решение сделает примерно 5×2,5 = 12,5 операций (для маленького массива разница не видна)
•	Для массива из 10000 элементов:
o	Плохое решение: около 50 миллионов операций
o	Хорошее решение: около 30000 операций


Задача 2: Самая длинная подпоследовательность без повторов
Условие 
Найти самую длинную непрерывную подпоследовательность (подмассив), в которой все элементы уникальны (нет повторений).
Оценка эффективного алгоритма
Сложность: O(n)
Эффективное решение:
•	Правый указатель (right) проходит все n элементов - это n операций
•	Левый указатель (left) двигается только вперёд и не больше n раз за всё время - ещё до n операций
•	Проверка, видели ли мы число - это просто обращение к массиву по индексу (одна операция)
•	Запись в массив - тоже одна операция
Итого примерно 2n операций, то есть O(n).
Почему работает быстрее:
•	Правая граница постоянно двигается вперёд, захватывая новые элементы
•	Если встречается повтор, левая граница перепрыгивает через первое вхождение повтора
•	Мы не перебираем все подмассивы заново, а только двигаем границы
Проверка на примере:
Для массива [1,2,3,1,2,3,4,5] будет примерно 16 операций
Для массива из 10000 элементов будет примерно 20000 операций
